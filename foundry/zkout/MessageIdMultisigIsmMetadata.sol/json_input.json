{
  "language": "Solidity",
  "sources": {
    "contracts/isms/libs/MessageIdMultisigIsmMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.0;\n\n/**\n * Format of metadata:\n * [   0:  32] Origin merkle tree address\n * [  32:  64] Signed checkpoint root\n * [  64:  68] Signed checkpoint index\n * [  68:????] Validator signatures (length := threshold * 65)\n */\nlibrary MessageIdMultisigIsmMetadata {\n    uint8 private constant ORIGIN_MERKLE_TREE_OFFSET = 0;\n    uint8 private constant MERKLE_ROOT_OFFSET = 32;\n    uint8 private constant MERKLE_INDEX_OFFSET = 64;\n    uint8 private constant SIGNATURES_OFFSET = 68;\n    uint8 private constant SIGNATURE_LENGTH = 65;\n\n    /**\n     * @notice Returns the origin merkle tree hook of the signed checkpoint as bytes32.\n     * @param _metadata ABI encoded Multisig ISM metadata.\n     * @return Origin merkle tree hook of the signed checkpoint as bytes32\n     */\n    function originMerkleTreeHook(\n        bytes calldata _metadata\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(\n                _metadata[ORIGIN_MERKLE_TREE_OFFSET:ORIGIN_MERKLE_TREE_OFFSET +\n                    32]\n            );\n    }\n\n    /**\n     * @notice Returns the merkle root of the signed checkpoint.\n     * @param _metadata ABI encoded Multisig ISM metadata.\n     * @return Merkle root of the signed checkpoint\n     */\n    function root(bytes calldata _metadata) internal pure returns (bytes32) {\n        return bytes32(_metadata[MERKLE_ROOT_OFFSET:MERKLE_ROOT_OFFSET + 32]);\n    }\n\n    /**\n     * @notice Returns the merkle index of the signed checkpoint.\n     * @param _metadata ABI encoded Multisig ISM metadata.\n     * @return Merkle index of the signed checkpoint\n     */\n    function index(bytes calldata _metadata) internal pure returns (uint32) {\n        return\n            uint32(\n                bytes4(_metadata[MERKLE_INDEX_OFFSET:MERKLE_INDEX_OFFSET + 4])\n            );\n    }\n\n    /**\n     * @notice Returns the validator ECDSA signature at `_index`.\n     * @dev Assumes signatures are sorted by validator\n     * @dev Assumes `_metadata` encodes `threshold` signatures.\n     * @dev Assumes `_index` is less than `threshold`\n     * @param _metadata ABI encoded Multisig ISM metadata.\n     * @param _index The index of the signature to return.\n     * @return The validator ECDSA signature at `_index`.\n     */\n    function signatureAt(\n        bytes calldata _metadata,\n        uint256 _index\n    ) internal pure returns (bytes calldata) {\n        uint256 _start = SIGNATURES_OFFSET + (_index * SIGNATURE_LENGTH);\n        uint256 _end = _start + SIGNATURE_LENGTH;\n        return _metadata[_start:_end];\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=node_modules/@openzeppelin/",
      "forge-std/=lib/forge-std/src/"
    ],
    "optimizer": {
      "enabled": true,
      "mode": "3",
      "details": null,
      "fallbackToOptimizingForSize": false,
      "disableSystemRequestMemoization": true
    },
    "outputSelection": {
      "*": {
        "": [
          "metadata"
        ],
        "*": [
          "abi",
          "evm.methodIdentifiers"
        ]
      }
    },
    "libraries": {},
    "isSystem": false,
    "forceEvmla": false,
    "areLibrariesMissing": false
  }
}